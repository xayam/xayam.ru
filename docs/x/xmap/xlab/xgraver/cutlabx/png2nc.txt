import sys

import numpy as np
import cv2
import winsound

from png2gif import greedy_path, matrix_path, contour_path, get_trajectory

#    Шаблоны заданий работы гравера:
# 1) WOOD - установлен синий лазер;
# 2) PLASTIC/METAL - установлен красный лазер;
# 3) GRAVE - гравировка (один проход);
# 4) BURN - резка (несколько проходов по кластерам, обычно хватает 5 раз);
WOOD_GRAVE = "wood_grave"
WOOD_BURN = "wood_burn"
PLASTIC_GRAVE = "plastic_grave"
METAL_GRAVE = "metal_grave"
METAL_BURN = "metal_burn"
ALGORITHM = "algorithm"
# алгоритм траекторий
# greedy_path медленно, много памяти и хорошо
# matrix_path быстро, мало памяти, но и иногда хуже
algorithm = contour_path
# algorithm = matrix_path
# ВВОД задания для гравера ЗДЕСЬ
task = WOOD_GRAVE

# калибровка по точке привязки
boundX = 5.1
boundY = 50.1

# приведение к формату А4
widthA4 = 297.0
heightA4 = 210.0

SPEED = "speed" # скорость передвижения лазера
POWER = "power" # мощность включения лазера в процентах
LOOP = "loop"   # количество проходов

# Все конфигурации заданий работы гравера
config = {
    WOOD_GRAVE: {
        ALGORITHM: algorithm,
        SPEED: 4000,
        POWER: 95,
        LOOP: 1
    },
    WOOD_BURN: {
        ALGORITHM: algorithm,
        SPEED: 400,
        POWER: 95,
        LOOP: 5
    },
    PLASTIC_GRAVE: {
        ALGORITHM: algorithm,
        SPEED: 1000,
        POWER: 95,
        LOOP: 1
    },
    METAL_GRAVE: {
        ALGORITHM: algorithm,
        SPEED: 1000,
        POWER: 100,
        LOOP: 1
    },
    METAL_BURN: {
        ALGORITHM: algorithm,
        SPEED: 400,
        POWER: 95,
        LOOP: 5
    }
}

# не менять
task = config[task]


def line_pixels(y0, x0, y1, x1):
    points = []
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    err = dx - dy
    while True:
        points.append((y0, x0))
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x0 += sx
        if e2 < dx:
            err += dx
            y0 += sy
    return points

def optimize(filename: str, algorithm, speed: str, loop: int = 1) -> str:
    width, height, binary_image, trajectory = \
        get_trajectory(filename=filename, algorithm=algorithm, animate=False)
    image = np.ones_like(binary_image) * 255
    result = ""
    for i in range(len(trajectory)):
        for l in range(loop):
            print(f"{i + 1}/{len(trajectory)} : {l + 1}/{loop}")
            cluster = trajectory[i]
            path = []
            y_pred = None
            for j in range(1, len(cluster)):
                flag = False
                ys1, xs1 = cluster[j - 1]
                ys2, xs2 = cluster[j]
                y1 = round(heightA4 - ys1 / height * heightA4 + boundY, 2)
                x1 = round(xs1 / width * widthA4 + boundX, 2)
                if j == 1:
                    result += f"G0X{x1}Y{y1}{speed}\n"
                    y_pred = y1
                y2 = round(heightA4 - ys2 / height * heightA4 + boundY, 2)
                x2 = round(xs2 / width * widthA4 + boundX, 2)
                # points = line_pixels(ys1, xs1, ys2, xs2)
                # for yy, xx in points:
                #     if binary_image[yy, xx] == 0:
                #         flag = True
                #         break
                # if not flag:
                path.append([x1, y1, x2, y2])
                s1 = f"G0X{x1}"
                if y1 != y_pred:
                    s1 += f"Y{y1}"
                    y_pred = y1
                s1 += "\n"
                if x1 != x2:
                    result += s1
                result += f"G1X{x2}"
                result += "\n"
                image = cv2.line(image, (xs1, ys1), (xs2, ys2),
                                     color=(0, 0, 0), thickness=1)
    cv2.imwrite("output.nc.png", image)
    return result


def get_gcode(algorithm, speed: int = 4000, power: int = 95, loop: int = 1):
    with open(f"begin.nc", 'r', encoding="UTF-8") as f:
        preamble = f.read()
    with open(f"end.nc", 'r', encoding="UTF-8") as f:
        postamble = f.read()
    speed = f"S{power * 10}.00F{speed}.00"
    optimized_points = optimize(filename="input.png", algorithm=algorithm,
                                speed=speed, loop=loop)

    with open("output.nc", 'w', encoding="UTF-8") as f:
        f.write(preamble)
        f.write("\n\n")
        f.write(";L0\n")
        f.write(optimized_points)
        f.write("\n\n")
        f.write(postamble)


if __name__ == "__main__":
    get_gcode(**task)
    winsound.Beep(1000, 1500)
