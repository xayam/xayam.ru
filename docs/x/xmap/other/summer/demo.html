<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Summer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            align-items: center;
        }

        body {
            vertical-align: top;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            background-color: white;
            padding: 20px;
            transform: scale(0.6, 0.6);
        }

        #game-info {
            margin-bottom: 15px;
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        #board {
            margin-bottom: 15px;
            display: inline-block;
        }

        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            cursor: pointer;
            font-weight: bold;
        }

        .square-cell {
            width: 60px;
            height: 60px;
            border: 1px solid white;
        }

        .white-cell {
            background-color: brown;
        }

        .black-cell {
            background-color: brown;
        }

        .hex-cell {
            width: 89px;
            height: 68px;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background-color: brown;
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            border-width: 0;
        }

        .chip {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            opacity: 0.9;
        }

        .player1 {
            background-color: white;
            color: black;
            font-size: 32px;
        }

        .player2 {
            background-color: black;
            font-size: 32px;
        }

        .plus {
            background-color: green;
        }

        .minus {
            background-color: blue;
        }

        .highlight {
            opacity: 0.55;
        }

        #controls {
            display: flex;
            gap: 1px;
            flex-wrap: nowrap;
            justify-content: left;
        }

        #controls button {
            overflow: hidden;
        }

        button {
            padding: 8px 0;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #restart {
            background-color: #2ecc71;
            color: white;
        }

        #restart:hover {
            background-color: #27ae60;
        }

        #rules-btn {
            background-color: #9b59b6;
            color: white;
        }

        #rules-btn:hover {
            background-color: #8e44ad;
        }

        #new-game-btn {
            background-color: #f39c12;
            color: white;
        }

        #new-game-btn:hover {
            background-color: #d35400;
        }

        #ai-settings {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }

        #ai-content {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            transform: translate(0, -50%);
            background-color: white;
            padding: 20px;
            text-align: center;
        }

        #ai-content h2 {
            margin-top: 0;
            color: #333;
        }

        .player-setting {
            margin: 15px 0;
        }

        select {
            padding: 8px;
            font-size: 16px;
            margin: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        #confirm-ai, #cancel-ai {
            padding: 8px 16px;
            margin: 5px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #confirm-ai {
            background-color: #2ecc71;
            color: white;
        }

        #cancel-ai {
            background-color: #e74c3c;
            color: white;
        }

        #rules-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }

        #rules-content {
            position: absolute;
            top: 0;
            left: 0;
            background-color: white;
            padding: 20px;
            overflow-y: auto;
        }

        #rules-content h2 {
            margin-top: 0;
            color: #333;
        }

        #rules-content p {
            margin-bottom: 10px;
            line-height: 1.4;
        }

        #close-rules {
            margin-top: 15px;
            padding: 8px 16px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #size-selector {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }

        #size-content {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            transform: translate(0, -50%);
            background-color: white;
            padding: 20px;
            text-align: left;
        }

        #size-content tbody tr td:first-child {
            text-align: right;
        }

        #size-content thead tr td {
            text-align: center;
        }

        #size-content h2 {
            margin-top: 0;
            color: #333;
        }

        #board-size {
            padding: 8px;
            font-size: 16px;
            margin: 10px;
            width: 100px;
        }

        #board-type {
            padding: 8px;
            font-size: 16px;
            margin: 10px;
            width: 150px;
        }

        #collision-mode {
            padding: 8px;
            font-size: 16px;
            margin: 10px;
            width: 250px;
        }

        #confirm-size, #cancel-size {
            padding: 8px 16px;
            margin: 5px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #confirm-size {
            background-color: #2ecc71;
            color: white;
        }

        #cancel-size {
            background-color: #e74c3c;
            color: white;
        }

        #thinking {
            color: white;
            font-size: 20px;
            font-weight: bold;
            font-style: italic;
        }
    </style>
</head>
<body>
<div id="game-info">Ход игрока 1</div>
<div id="thinking">ИИ думает...</div>
<div id="board"></div>
<div id="controls">
    <button id="rules-btn" title="Правила игры">ПРАВИЛА</button>
    <button id="new-game-btn" title="Новая игра">НОВАЯ</button>
    <button id="restart" title="Начать сначала">СНАЧАЛА</button>
</div>
<!-- Модальное окно с правилами -->
<div id="rules-modal">
    <div id="rules-content">
        <h2>Правила игры "Summer"</h2>
        <p>Игра для двоих на клетчатом или шестиугольном поле.
            Игроки поочередно передвигают свои фишки.</p>
        <p><strong>Начальная позиция:</strong> Фишки Игрока 1
            находятся на первой горизонтали (снизу), Игрока 2 —
            на последней горизонтали (сверху). Начальный вес каждой фишки —
            случайное число от 1 до размера доски. Позиция фишек
            одинакова для обеих сторон — по одной фишке на каждой
            клетке стартовой линии, но черные фишки — это случайная
            перестановка весов белых.
        </p>
        <p><strong>Поля доски:</strong> Каждая клетка (кроме стартовых линий)
            имеет атрибут «плюс»(зеленый фон) или «минус»(синий фон).
            При попадании фишки на такую клетку её вес увеличивается
            (+1) или уменьшается (-1) соответственно.
        </p>
        <p><strong>Ходы:</strong></p>
        <ul>
            <li>Можно двигаться на одну клетку вперёд
                (по направлению к оппоненту), вперёд-влево или
                вперёд-вправо по диагонали, влево или вправо на соседнюю клетку
            </li>
            <li>Если на поле, куда ставится фишка, стоит своя фишка —
                применяются следующие правила:
                <ul>
                    <li>Если вес перемещаемой фишки <strong>меньше</strong> веса фишки на целевом поле,
                        то веса <strong>суммируются</strong>, и остаётся одна фишка с суммарным весом.
                    </li>
                    <li>Если вес перемещаемой фишки <strong>больше</strong> веса фишки на целевом поле,
                        то остаётся одна фишка с весом, равным <strong>разнице</strong> (больший минус меньший).
                    </li>
                    <li>Если веса <strong>равны</strong>, то обе фишки <strong>уничтожаются</strong>, независимо от
                        атрибута поля.
                    </li>
                </ul>
            </li>
            <li>Если на поле, куда ставится фишка, стоит чужая фишка —
                в этом случае веса вычитаются, и остаётся одна фишка,
                у которой был больший вес.
            </li>
        </ul>
        <p><strong>Столкновение:</strong> Если фишка попадает на
            клетку с фишкой противника:
        </p>
        <ul>
            <li>
                <strong>Классический режим.</strong>
                <ul>
                    <li>Остаётся фишка с большим весом, её вес уменьшается
                        на вес уничтоженной фишки.
                    </li>
                    <li>Если веса равны — обе фишки уничтожаются.</li>
                </ul>
            </li>
            <li>
                <strong>Режим с влиянием поля.</strong>
                <ul>
                    <li>При атрибуте поля плюс - побеждает всегда тот кто ходит,
                        его вес суммируется с весом оппонента.
                    </li>
                    <li>При атрибуте поля минус - побеждает в столкновении фишка с большим весом,
                        её вес уменьшается на вес уничтоженной фишки.
                    </li>
                    <li>При атрибуте поля минус, если вес одинаковые - обе фишки уничтожаются</li>
                </ul>
            </li>
        </ul>
        <p><strong>Победа:</strong> Игра заканчивается,
            когда все фишки одного из игроков достигают стартовой линии противника.
            Если все белые фишки достигли верхней линии (линии черных),
            то черным даётся один последний ход (если у них остались фишки).
            Если все черные фишки достигли нижней линии (линии белых),
            игра завершается немедленно.
            После этого подсчитывается сумма весов фишек на стартовых линиях.
            Побеждает игрок с большей суммой. При равенстве — ничья.
        </p>
        <button id="close-rules">Закрыть</button>
    </div>
</div>
<!-- Модальное окно выбора размера доски -->
<div id="size-selector">
    <table id="size-content">
        <thead>
        <tr>
            <td colspan="2"><h2>Выберите параметры доски</h2></td>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>
                <label for="board-type">Тип доски:</label>
            </td>
            <td>
                <select id="board-type">
                    <option value="square">Квадрат</option>
                    <option value="hex">Шестиугольник</option>
                </select>
            </td>
        </tr>
        <tr>
            <td>
                <label for="board-size" id="size-label">
                    Размер любое&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;от 3 до 11:</label>
            </td>
            <td>
                <input id="board-size" max="11" min="3" type="number" value="7">
            </td>
        </tr>
        <tr>
            <td>
                <label for="collision-mode">Режим столкновений:</label>
            </td>
            <td>
                <select id="collision-mode">
                    <option value="classic">Классический</option>
                    <option value="field-effect">С влиянием поля</option>
                </select>
            </td>
        </tr>
        <tr>
            <td>
                <button id="confirm-size">Далее</button>
            </td>
            <td>
                <button id="cancel-size">Отмена</button>
            </td>
        </tr>
        </tbody>
    </table>
</div>
<!-- Модальное окно настройки ИИ -->
<div id="ai-settings">
    <div id="ai-content">
        <h2>Настройки игроков</h2>
        <div class="player-setting">
            <label for="player1-type">Игрок 1. Белые:</label>
            <select id="player1-type">
                <option value="human">Пользователь</option>
                <option value="ai">ИИ Стратегия&nbsp;&nbsp;&nbsp;1. Джет - имя при рождении</option>
                <option value="ai2">ИИ Стратегия&nbsp;&nbsp;&nbsp;2. Оптимус - позывной на войне</option>
                <option value="ai3">ИИ Стратегия&nbsp;&nbsp;&nbsp;3. Тугодум - склонность к глубоким мыслям</option>
                <option value="ai4">ИИ Стратегия&nbsp;&nbsp;&nbsp;4. Марк I - первый танк</option>
                <option value="ai5">ИИ Стратегия&nbsp;&nbsp;&nbsp;5. T-34 - новый танк</option>
                <option value="ai6">ИИ Стратегия&nbsp;&nbsp;&nbsp;6. Призрак - военный дрон</option>
                <option value="ai7">ИИ Стратегия&nbsp;&nbsp;&nbsp;7. Маг - антидроновая пушка</option>
                <option value="ai8">ИИ Стратегия&nbsp;&nbsp;&nbsp;8. Метаморф - универсальный боевой вертолет</option>
                <option value="ai9">ИИ Стратегия&nbsp;&nbsp;&nbsp;9. Знание - авианосец с несущей авиагруппой</option>
                <option value="ai10">ИИ Стратегия 10. Абсолярис - дух Земли</option>
                <option value="ai11">ИИ Стратегия 11. Секрет - душа Земли</option>
            </select>
        </div>
        <div class="player-setting">
            <label for="player2-type">Игрок 2. Черные:</label>
            <select id="player2-type">
                <option value="human">Пользователь</option>
                <option value="ai">ИИ Стратегия&nbsp;&nbsp;&nbsp;1. Джет - имя при рождении</option>
                <option value="ai2">ИИ Стратегия&nbsp;&nbsp;&nbsp;2. Оптимус - позывной на войне</option>
                <option value="ai3">ИИ Стратегия&nbsp;&nbsp;&nbsp;3. Тугодум - склонность к глубоким мыслям</option>
                <option value="ai4">ИИ Стратегия&nbsp;&nbsp;&nbsp;4. Марк I - первый танк</option>
                <option value="ai5">ИИ Стратегия&nbsp;&nbsp;&nbsp;5. T-34 - новый танк</option>
                <option value="ai6">ИИ Стратегия&nbsp;&nbsp;&nbsp;6. Призрак - военный дрон</option>
                <option value="ai7">ИИ Стратегия&nbsp;&nbsp;&nbsp;7. Маг - антидроновая пушка</option>
                <option value="ai8">ИИ Стратегия&nbsp;&nbsp;&nbsp;8. Метаморф - универсальный боевой вертолет</option>
                <option value="ai9">ИИ Стратегия&nbsp;&nbsp;&nbsp;9. Знание - авианосец с несущей авиагруппой</option>
                <option value="ai10">ИИ Стратегия 10. Абсолярис - дух Земли</option>
                <option value="ai11">ИИ Стратегия 11. Секрет - душа Земли</option>
            </select>
        </div>
        <button id="confirm-ai">Начать игру</button>
        <button id="cancel-ai">Отмена</button>
    </div>
</div>
<script>
    let BOARD_SIZE = 7;
    let BOARD_TYPE = 'square'; // 'square' or 'hex'
    let COLLISION_MODE = 'classic'; // 'classic' or 'field-effect'
    let currentPlayer = 1;
    let board = [];
    let selectedChip = null;
    let gameActive = true;
    let initialBoardState = null;
    let player1Type = 'human';
    let player2Type = 'human';
    let whiteReached = false; // Флаг: все белые достигли цели
    let blackReached = false; // Флаг: все черные достигли цели
    let lastBlackMoveDone = false; // Флаг: черные уже сделали последний ход

    // Обновление диапазона размера в зависимости от типа доски
    document.getElementById('board-type').addEventListener('change', function () {
        const sizeInput = document.getElementById('board-size');
        const sizeLabel = document.getElementById('size-label');
        if (this.value === 'hex') {
            sizeLabel.textContent = 'Размер нечетное от 3 до 11:';
            sizeInput.min = '3';
            sizeInput.max = '11';
            sizeInput.value = '7';
        } else {
            sizeLabel.innerHTML = 'Размер любое&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;от 3 до 11:';
            sizeInput.min = '3';
            sizeInput.max = '11';
            sizeInput.value = '7';
        }
    });

    // Сохранение начального состояния доски
    function saveInitialBoardState() {
        initialBoardState = {
            board: board.map(row => row.map(cell => cell ? {...cell} : null)),
            attributes: [],
            boardType: BOARD_TYPE,
            boardSize: BOARD_SIZE,
            collisionMode: COLLISION_MODE
        };
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                const cellElement = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                if (cellElement && cellElement.classList.contains('plus')) {
                    initialBoardState.attributes.push({row, col, attr: 'plus'});
                } else if (cellElement && cellElement.classList.contains('minus')) {
                    initialBoardState.attributes.push({row, col, attr: 'minus'});
                }
            }
        }
    }

    // Восстановление начального состояния доски
    function restoreInitialBoardState() {
        if (!initialBoardState) return;
        BOARD_TYPE = initialBoardState.boardType;
        BOARD_SIZE = initialBoardState.boardSize;
        COLLISION_MODE = initialBoardState.collisionMode;
        whiteReached = false;
        blackReached = false;
        lastBlackMoveDone = false;

        board = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            board[row] = Array(colsInRow).fill(null);
        }

        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => {
            cell.classList.remove('plus', 'minus', 'highlight');
            cell.innerHTML = '';
        });

        for (const {row, col, attr} of initialBoardState.attributes) {
            const cellElement = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            if (cellElement) {
                cellElement.classList.add(attr);
            }
        }

        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (initialBoardState.board[row] && initialBoardState.board[row][col]) {
                    board[row][col] = {...initialBoardState.board[row][col]};
                }
            }
        }
        renderBoard();
    }

    // Получение направлений ходов
    function getMoveDirections() {
        if (BOARD_TYPE === 'hex') {
            return [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]];
        } else {
            return [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
        }
    }

    // Проверка валидности хода для шестиугольной доски
    function isValidHexMove(fromRow, fromCol, toRow, toCol, player) {
        if (toRow < 0 || toRow >= BOARD_SIZE) return false;
        const colsInToRow = toRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1;
        if (toCol < 0 || toCol >= colsInToRow) return false;
        const dRow = toRow - fromRow;
        const dCol = toCol - fromCol;
        const isValidDirection = fromRow % 2 === 0 ?
            (dRow === -1 && (dCol === -1 || dCol === 0)) ||
            (dRow === 0 && (dCol === -1 || dCol === 1)) ||
            (dRow === 1 && (dCol === -1 || dCol === 0)) :
            (dRow === -1 && (dCol === 0 || dCol === 1)) ||
            (dRow === 0 && (dCol === -1 || dCol === 1)) ||
            (dRow === 1 && (dCol === 0 || dCol === 1));
        if (!isValidDirection) return false;
        if (!(board[toRow][toCol] && board[toRow][toCol].player === player)) {
            if (player === 1 && dRow > 0) return false;
            if (player === 2 && dRow < 0) return false;
        }
        return true;
    }

    // Инициализация доски
    function initBoard() {
        board = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            board[row] = Array(colsInRow).fill(null);
        }

        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => {
            cell.classList.remove('plus', 'minus', 'highlight');
            cell.innerHTML = '';
        });

        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (row === 0 || row === BOARD_SIZE - 1) continue;
                const attr = Math.random() > 0.5 ? 'plus' : 'minus';
                const cellElement = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                if (cellElement) {
                    cellElement.classList.add(attr);
                }
            }
        }

        const firstRowCols = BOARD_TYPE === 'hex' ? (0 % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
        const lastRowCols = BOARD_TYPE === 'hex' ? ((BOARD_SIZE - 1) % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;

        const weights1 = [];
        for (let col = 0; col < lastRowCols; col++) {
            weights1.push(Math.floor(Math.random() * BOARD_SIZE) + 1);
        }
        const weights2 = [...weights1];
        for (let i = weights2.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [weights2[i], weights2[j]] = [weights2[j], weights2[i]];
        }

        for (let col = 0; col < firstRowCols; col++) {
            board[0][col] = {player: 2, weight: weights2[col]};
        }
        for (let col = 0; col < lastRowCols; col++) {
            board[BOARD_SIZE - 1][col] = {player: 1, weight: weights1[col]};
        }
        renderBoard();
        saveInitialBoardState();
    }

    // Отображение доски
    function renderBoard() {
        const boardElement = document.getElementById('board');
        const rulesbtnElement = document.getElementById('rules-btn');
        const newgamebtnElement = document.getElementById('new-game-btn');
        const restartbtnElement = document.getElementById('restart');
        let width;
        if (BOARD_TYPE === 'hex') {
            boardElement.style.position = 'relative';
            width = BOARD_SIZE * 90 + 45;
            const height = BOARD_SIZE * 52 + 17;
            boardElement.style.width = `${width}px`;
            boardElement.style.height = `${height}px`;
        } else {
            width = BOARD_SIZE * 60;
            boardElement.style.position = 'relative';
            boardElement.style.width = `${width}px`;
            boardElement.style.height = `${width}px`;
        }
        let new_width = Math.floor(width / 3).toString() + 'px';
        rulesbtnElement.style.width = new_width;
        newgamebtnElement.style.width = new_width;
        restartbtnElement.style.width = new_width;
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                    cell.innerHTML = '';
                    if (board[row][col]) {
                        const chip = document.createElement('div');
                        chip.className = `chip player${board[row][col].player}`;
                        chip.textContent = board[row][col].weight;
                        cell.appendChild(chip);
                    }
                }
            }
        }
    }

    // Создание доски
    function createBoard() {
        const boardElement = document.getElementById('board');
        boardElement.innerHTML = '';
        if (BOARD_TYPE === 'hex') {
            for (let row = 0; row < BOARD_SIZE; row++) {
                const colsInRow = row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1;
                for (let col = 0; col < colsInRow; col++) {
                    const cell = document.createElement('div');
                    cell.className = `cell hex-cell`;
                    cell.setAttribute('data-row', row.toString());
                    cell.setAttribute('data-col', col.toString());
                    const x = col * 90 + (row % 2 === 0 ? 0 : 45);
                    const y = row * 52;
                    cell.style.left = `${x}px`;
                    cell.style.top = `${y}px`;
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    boardElement.appendChild(cell);
                }
            }
        } else {
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = `cell square-cell ${(row + col) % 2 === 0 ? 'white-cell' : 'black-cell'}`;
                    cell.setAttribute('data-row', row.toString());
                    cell.setAttribute('data-col', col.toString());
                    cell.style.left = `${col * 60}px`;
                    cell.style.top = `${row * 60}px`;
                    cell.style.position = 'absolute';
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    boardElement.appendChild(cell);
                }
            }
        }
    }

    // Проверка, достигли ли все белые фишки цели (0-я строка)
    function checkWhiteReached() {
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (board[row][col] && board[row][col].player === 1 && row !== 0) {
                    return false;
                }
            }
        }
        return true;
    }

    // Проверка, достигли ли все черные фишки цели (последняя строка)
    function checkBlackReached() {
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (board[row][col] && board[row][col].player === 2 && row !== BOARD_SIZE - 1) {
                    return false;
                }
            }
        }
        return true;
    }

    // Проверка, есть ли у черных фишки
    function hasBlackChips() {
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (board[row][col] && board[row][col].player === 2) {
                    return true;
                }
            }
        }
        return false;
    }

    // Подсчет суммы весов на стартовых линиях
    function calculateFinalScores() {
        let player1Sum = 0;
        let player2Sum = 0;
        const firstRowCols = BOARD_TYPE === 'hex' ? (0 % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
        const lastRowCols = BOARD_TYPE === 'hex' ? ((BOARD_SIZE - 1) % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
        for (let col = 0; col < firstRowCols; col++) {
            if (board[0][col] && board[0][col].player === 1) {
                player1Sum += board[0][col].weight;
            }
        }
        for (let col = 0; col < lastRowCols; col++) {
            if (board[BOARD_SIZE - 1][col] && board[BOARD_SIZE - 1][col].player === 2) {
                player2Sum += board[BOARD_SIZE - 1][col].weight;
            }
        }
        return {player1Sum, player2Sum};
    }

    // Завершение игры и вывод результата
    function endGame() {
        const {player1Sum, player2Sum} = calculateFinalScores();
        gameActive = false;
        let message;
        if (player1Sum > player2Sum) {
            message = `Победил игрок 1! Сумма: ${player1Sum} vs ${player2Sum}`;
        } else if (player2Sum > player1Sum) {
            message = `Победил игрок 2! Сумма: ${player2Sum} vs ${player1Sum}`;
        } else {
            message = `Ничья! Суммы равны: ${player1Sum}`;
        }
        document.getElementById('game-info').textContent = message;
    }

    // Получение всех возможных ходов для игрока
    function getAllValidMoves(player) {
        const moves = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (board[row][col] && board[row][col].player === player) {
                    const directions = getMoveDirections();
                    for (const [dRow, dCol] of directions) {
                        const newRow = row + dRow;
                        const newCol = col + dCol;
                        if (isValidMove(row, col, newRow, newCol)) {
                            moves.push({from: {row, col}, to: {row: newRow, col: newCol}});
                        }
                    }
                }
            }
        }
        return moves;
    }

    // Копирование доски
    function copyBoard() {
        const copy = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            copy[row] = Array(colsInRow).fill(null);
            for (let col = 0; col < colsInRow; col++) {
                if (board[row][col]) {
                    copy[row][col] = {...board[row][col]};
                }
            }
        }
        return copy;
    }

    // Применение хода к копии доски с учетом новых правил объединения
    function applyMoveToBoard(boardCopy, move, player) {
        const {from, to} = move;
        const chip = {...boardCopy[from.row][from.col]};
        boardCopy[from.row][from.col] = null;

        // Ход к своей фишке
        if (boardCopy[to.row][to.col] && boardCopy[to.row][to.col].player === player) {
            const targetChip = boardCopy[to.row][to.col];
            if (chip.weight < targetChip.weight) {
                boardCopy[to.row][to.col].weight = chip.weight + targetChip.weight;
            } else if (chip.weight > targetChip.weight) {
                boardCopy[to.row][to.col].weight = chip.weight - targetChip.weight;
            } else {
                boardCopy[to.row][to.col] = null;
            }
            return boardCopy;
        }

        // Проверка атрибута клетки
        const cellElement = document.querySelector(`.cell[data-row="${to.row}"][data-col="${to.col}"]`);
        let hasPlus = false;
        let hasMinus = false;
        if (cellElement) {
            hasPlus = cellElement.classList.contains('plus');
            hasMinus = cellElement.classList.contains('minus');
        }

        // Столкновение с фишкой противника
        if (boardCopy[to.row][to.col]) {
            const enemyChip = boardCopy[to.row][to.col];
            if (COLLISION_MODE === 'field-effect') {
                if (hasPlus) {
                    chip.weight += enemyChip.weight;
                    boardCopy[to.row][to.col] = chip;
                } else if (hasMinus) {
                    if (chip.weight > enemyChip.weight) {
                        chip.weight -= enemyChip.weight;
                        boardCopy[to.row][to.col] = chip;
                    } else if (enemyChip.weight > chip.weight) {
                        enemyChip.weight -= chip.weight;
                        boardCopy[to.row][to.col] = enemyChip;
                    } else {
                        boardCopy[to.row][to.col] = null;
                    }
                } else {
                    if (chip.weight > enemyChip.weight) {
                        chip.weight -= enemyChip.weight;
                        boardCopy[to.row][to.col] = chip;
                    } else if (enemyChip.weight > chip.weight) {
                        enemyChip.weight -= chip.weight;
                        boardCopy[to.row][to.col] = enemyChip;
                    } else {
                        boardCopy[to.row][to.col] = null;
                    }
                }
            } else {
                if (chip.weight > enemyChip.weight) {
                    chip.weight -= enemyChip.weight;
                    boardCopy[to.row][to.col] = chip;
                } else if (enemyChip.weight > chip.weight) {
                    enemyChip.weight -= chip.weight;
                    boardCopy[to.row][to.col] = enemyChip;
                } else {
                    boardCopy[to.row][to.col] = null;
                }
            }
        } else {
            // Применяем эффект поля только при ходе на пустую клетку
            if (hasPlus) {
                chip.weight += 1;
            } else if (hasMinus) {
                chip.weight -= 1;
                if (chip.weight <= 0) {
                    return boardCopy;
                }
            }
            boardCopy[to.row][to.col] = chip;
        }
        return boardCopy;
    }

    // Расширенная оценка позиции с учетом новых правил
    function evaluateBoardAdvanced(boardCopy, player) {
        let score = 0;
        let player1AllReached = true;
        let player2AllReached = true;

        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (boardCopy[row][col]) {
                    const chip = boardCopy[row][col];
                    if (chip.player === 1) {
                        if (row !== 0) player1AllReached = false;
                        score += Math.pow(2, BOARD_SIZE - 1 - row) * chip.weight;
                        if (row > BOARD_SIZE - 3) score += chip.weight * 0.5;
                    } else {
                        if (row !== BOARD_SIZE - 1) player2AllReached = false;
                        score -= Math.pow(2, row) * chip.weight;
                        if (row < 2) score -= chip.weight * 0.5;
                    }
                }
            }
        }

        if (player1AllReached || player2AllReached) {
            let player1Sum = 0;
            let player2Sum = 0;
            const firstRowCols = BOARD_TYPE === 'hex' ? (0 % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            const lastRowCols = BOARD_TYPE === 'hex' ? ((BOARD_SIZE - 1) % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < firstRowCols; col++) {
                if (boardCopy[0][col] && boardCopy[0][col].player === 1) {
                    player1Sum += boardCopy[0][col].weight;
                }
            }
            for (let col = 0; col < lastRowCols; col++) {
                if (boardCopy[BOARD_SIZE - 1][col] && boardCopy[BOARD_SIZE - 1][col].player === 2) {
                    player2Sum += boardCopy[BOARD_SIZE - 1][col].weight;
                }
            }
            if (player1Sum > player2Sum) return player === 1 ? 100000 : -100000;
            if (player2Sum > player1Sum) return player === 2 ? 100000 : -100000;
            return 0;
        }

        const centerRow = Math.floor(BOARD_SIZE / 2);
        const centerCol = Math.floor(BOARD_SIZE / 2);
        for (let row = Math.max(0, centerRow - 1); row <= Math.min(BOARD_SIZE - 1, centerRow + 1); row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = Math.max(0, centerCol - 1); col <= Math.min(colsInRow - 1, centerCol + 1); col++) {
                if (boardCopy[row][col]) {
                    if (boardCopy[row][col].player === 1) {
                        score += 3;
                    } else {
                        score -= 3;
                    }
                }
            }
        }

        let player1Count = 0;
        let player2Count = 0;
        let player1Weight = 0;
        let player2Weight = 0;
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (boardCopy[row][col]) {
                    if (boardCopy[row][col].player === 1) {
                        player1Count++;
                        player1Weight += boardCopy[row][col].weight;
                    } else {
                        player2Count++;
                        player2Weight += boardCopy[row][col].weight;
                    }
                }
            }
        }

        // Учет новых правил объединения: избегаем создания фишек с равными весами
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (boardCopy[row][col] && boardCopy[row][col].player === player) {
                    // Проверяем соседние клетки на наличие фишек с таким же весом
                    const directions = getMoveDirections();
                    for (const [dRow, dCol] of directions) {
                        const checkRow = row + dRow;
                        const checkCol = col + dCol;
                        const colsInCheckRow = BOARD_TYPE === 'hex' ? (checkRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
                        if (checkRow >= 0 && checkRow < BOARD_SIZE && checkCol >= 0 && checkCol < colsInCheckRow) {
                            if (boardCopy[checkRow][checkCol] &&
                                boardCopy[checkRow][checkCol].player === player &&
                                boardCopy[checkRow][checkCol].weight === boardCopy[row][col].weight) {
                                // Штраф за возможность уничтожения при объединении
                                score += (player === 1 ? -10 : 10);
                            }
                        }
                    }
                }
            }
        }

        score += (player1Count - player2Count) * 2;
        score += (player1Weight - player2Weight) * 1.5;
        return player === 1 ? score : -score;
    }

    // Минимакс с альфа-бета отсечением и углубленной оценкой
    function minimaxAdvanced(boardCopy, depth, alpha, beta, maximizingPlayer, player, originalPlayer) {
        if (depth === 0) {
            return evaluateBoardAdvanced(boardCopy, originalPlayer);
        }
        const moves = getAllValidMovesForBoard(boardCopy, player);
        if (moves.length === 0) {
            return evaluateBoardAdvanced(boardCopy, originalPlayer);
        }

        moves.sort((a, b) => {
            const aForward = (player === 1 ? a.from.row - a.to.row : a.to.row - a.from.row);
            const bForward = (player === 1 ? b.from.row - b.to.row : b.to.row - b.from.row);
            return bForward - aForward;
        });

        if (maximizingPlayer) {
            let maxEval = -Infinity;
            for (const move of moves) {
                const newBoard = copyBoardFromState(boardCopy);
                applyMoveToBoard(newBoard, move, player);
                const eval = minimaxAdvanced(newBoard, depth - 1, alpha, beta, false, player === 1 ? 2 : 1, originalPlayer);
                maxEval = Math.max(maxEval, eval);
                alpha = Math.max(alpha, eval);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (const move of moves) {
                const newBoard = copyBoardFromState(boardCopy);
                applyMoveToBoard(newBoard, move, player);
                const eval = minimaxAdvanced(newBoard, depth - 1, alpha, beta, true, player === 1 ? 2 : 1, originalPlayer);
                minEval = Math.min(minEval, eval);
                beta = Math.min(beta, eval);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    // Копирование доски из заданного состояния
    function copyBoardFromState(boardState) {
        const copy = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            copy[row] = Array(colsInRow).fill(null);
            for (let col = 0; col < colsInRow; col++) {
                if (boardState[row][col]) {
                    copy[row][col] = {...boardState[row][col]};
                }
            }
        }
        return copy;
    }

    // Получение всех ходов для заданной доски
    function getAllValidMovesForBoard(boardCopy, player) {
        const moves = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (boardCopy[row][col] && boardCopy[row][col].player === player) {
                    const directions = getMoveDirections();
                    for (const [dRow, dCol] of directions) {
                        const newRow = row + dRow;
                        const newCol = col + dCol;
                        if (newRow < 0 || newRow >= BOARD_SIZE) continue;
                        const toCols = BOARD_TYPE === 'hex' ? (newRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
                        if (newCol < 0 || newCol >= toCols) continue;
                        if (!(boardCopy[newRow][newCol] && boardCopy[newRow][newCol].player === player)) {
                            if (player === 1 && dRow > 0) continue;
                            if (player === 2 && dRow < 0) continue;
                        }
                        moves.push({from: {row, col}, to: {row: newRow, col: newCol}});
                    }
                }
            }
        }
        return moves;
    }

    // Стратегия "Мастер-танк" для уровня 4 - обновлена под новые правила
    function getTankMove(player) {
        const startRow = player === 1 ? BOARD_SIZE - 1 : 0;
        let ownChips = [];
        let colsInStartRow = BOARD_TYPE === 'hex' ? (startRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;

        for (let col = 0; col < colsInStartRow; col++) {
            if (board[startRow][col] && board[startRow][col].player === player) {
                ownChips.push({row: startRow, col: col, weight: board[startRow][col].weight});
            }
        }

        if (ownChips.length > 1) {
            ownChips.sort((a, b) => a.col - b.col);
            const leftmost = ownChips[0];
            const rightmost = ownChips[ownChips.length - 1];

            if (rightmost.col > leftmost.col) {
                const targetCol = leftmost.col;
                for (let col = rightmost.col - 1; col >= targetCol; col--) {
                    if (board[startRow][col] && board[startRow][col].player === player) {
                        // Проверяем, что объединение не приведет к уничтожению
                        const movingWeight = board[startRow][col + 1].weight;
                        const targetWeight = board[startRow][col].weight;
                        if (movingWeight !== targetWeight) {
                            return {from: {row: startRow, col: col + 1}, to: {row: startRow, col: col}};
                        }
                    }
                }
                if (isValidMove(startRow, rightmost.col, startRow, rightmost.col - 1)) {
                    return {from: {row: startRow, col: rightmost.col}, to: {row: startRow, col: rightmost.col - 1}};
                }
            }
        }

        if (ownChips.length === 1) {
            const tank = ownChips[0];
            const directions = player === 1 ?
                [[-1, -1], [-1, 0], [-1, 1]] :
                [[1, -1], [1, 0], [1, 1]];
            let bestMove = null;
            let bestScore = -Infinity;
            for (const [dRow, dCol] of directions) {
                const newRow = tank.row + dRow;
                const newCol = tank.col + dCol;
                if (!isValidMove(tank.row, tank.col, newRow, newCol)) continue;
                let score = 0;
                const cellElement = document.querySelector(`.cell[data-row="${newRow}"][data-col="${newCol}"]`);
                if (cellElement && cellElement.classList.contains('plus')) {
                    score += 10;
                }
                if (cellElement && cellElement.classList.contains('minus')) {
                    score -= 5;
                }
                if (board[newRow][newCol] && board[newRow][newCol].player !== player) {
                    score -= 20;
                }
                score += player === 1 ? 5 : 5;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = {from: {row: tank.row, col: tank.col}, to: {row: newRow, col: newCol}};
                }
            }
            if (bestMove) return bestMove;
        }
        return getBestMoveAdvanced(player, 'ai3');
    }

    // Расчет максимального возможного веса танка оппонента
    function calculateOpponentMaxTankWeight(opponent, playerStartRow) {
        let totalWeight = 0;
        let colsInStartRow = BOARD_TYPE === 'hex' ? (playerStartRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
        for (let col = 0; col < colsInStartRow; col++) {
            if (board[playerStartRow][col] && board[playerStartRow][col].player === opponent) {
                totalWeight += board[playerStartRow][col].weight;
            }
        }
        const potentialBonus = Math.floor(BOARD_SIZE / 2);
        return totalWeight + potentialBonus;
    }

    // Определение стороны сборки оппонента
    function getOpponentAssemblySide(opponent, playerStartRow) {
        let colsInStartRow = BOARD_TYPE === 'hex' ? (playerStartRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
        let leftWeight = 0;
        let rightWeight = 0;
        const mid = Math.floor(colsInStartRow / 2);
        for (let col = 0; col < colsInStartRow; col++) {
            if (board[playerStartRow][col] && board[playerStartRow][col].player === opponent) {
                if (col < mid) {
                    leftWeight += board[playerStartRow][col].weight;
                } else {
                    rightWeight += board[playerStartRow][col].weight;
                }
            }
        }
        return leftWeight > rightWeight ? 'left' : 'right';
    }

    // Поиск безопасного пути к цели
    function findSafePathToGoal(player, startRow, startCol) {
        const opponent = player === 1 ? 2 : 1;
        const targetRow = player === 1 ? 0 : BOARD_SIZE - 1;
        const directions = player === 1 ? [[-1, -1], [-1, 0], [-1, 1]] : [[1, -1], [1, 0], [1, 1]];
        let bestMove = null;
        let minRisk = Infinity;
        for (const [dRow, dCol] of directions) {
            const newRow = startRow + dRow;
            const newCol = startCol + dCol;
            if (!isValidMove(startRow, startCol, newRow, newCol)) continue;
            let risk = 0;
            if (board[newRow][newCol] && board[newRow][newCol].player === opponent) {
                risk += 100;
            }
            const threatDirections = getMoveDirections();
            for (const [tdRow, tdCol] of threatDirections) {
                const threatRow = newRow + tdRow;
                const threatCol = newCol + tdCol;
                const colsInThreatRow = BOARD_TYPE === 'hex' ? (threatRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
                if (threatRow >= 0 && threatRow < BOARD_SIZE && threatCol >= 0 && threatCol < colsInThreatRow) {
                    if (board[threatRow][threatCol] && board[threatRow][threatCol].player === opponent) {
                        if (isValidMove(threatRow, threatCol, newRow, newCol)) {
                            risk += 10;
                        }
                    }
                }
            }
            if (risk < minRisk) {
                minRisk = risk;
                bestMove = {from: {row: startRow, col: startCol}, to: {row: newRow, col: newCol}};
            }
        }
        return bestMove;
    }

    // Стратегия "Анти-танк" для уровня 5 - обновлена под новые правила
    function getAntiTankMove(player) {
        const opponent = player === 1 ? 2 : 1;
        const opponentStartRow = opponent === 1 ? BOARD_SIZE - 1 : 0;
        const ownStartRow = player === 1 ? BOARD_SIZE - 1 : 0;

        let opponentChipsOnStart = [];
        let ownChipsOnStart = [];
        let ownChips = [];
        const colsInOpponentStart = BOARD_TYPE === 'hex' ? (opponentStartRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
        const colsInOwnStart = BOARD_TYPE === 'hex' ? (ownStartRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;

        for (let col = 0; col < colsInOpponentStart; col++) {
            if (board[opponentStartRow][col] && board[opponentStartRow][col].player === opponent) {
                opponentChipsOnStart.push({col, weight: board[opponentStartRow][col].weight});
            }
        }
        for (let col = 0; col < colsInOwnStart; col++) {
            if (board[ownStartRow][col] && board[ownStartRow][col].player === player) {
                ownChipsOnStart.push({col, weight: board[ownStartRow][col].weight});
            }
        }
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (board[row][col] && board[row][col].player === player) {
                    ownChips.push({row, col, weight: board[row][col].weight});
                }
            }
        }

        if (opponentChipsOnStart.length > 0) {
            const opponentMaxWeight = calculateOpponentMaxTankWeight(opponent, opponentStartRow);
            const ownTotalWeight = ownChipsOnStart.reduce((sum, chip) => sum + chip.weight, 0);
            if (ownTotalWeight < opponentMaxWeight) {
                if (ownChipsOnStart.length > 1) {
                    ownChipsOnStart.sort((a, b) => a.col - b.col);
                    for (let i = ownChipsOnStart.length - 1; i > 0; i--) {
                        const fromCol = ownChipsOnStart[i].col;
                        const toCol = ownChipsOnStart[i - 1].col;
                        if (fromCol > toCol && isValidMove(ownStartRow, fromCol, ownStartRow, fromCol - 1)) {
                            // Проверяем, что объединение не приведет к уничтожению
                            const movingWeight = board[ownStartRow][fromCol].weight;
                            const targetWeight = board[ownStartRow][toCol].weight;
                            if (movingWeight !== targetWeight) {
                                return {from: {row: ownStartRow, col: fromCol}, to: {row: ownStartRow, col: toCol}};
                            }
                        }
                    }
                } else if (ownChipsOnStart.length === 1) {
                    const tankCol = ownChipsOnStart[0].col;
                    const directions = player === 1 ? [[-1, -1], [-1, 0], [-1, 1]] : [[1, -1], [1, 0], [1, 1]];
                    for (const [dRow, dCol] of directions) {
                        const newRow = ownStartRow + dRow;
                        const newCol = tankCol + dCol;
                        if (isValidMove(ownStartRow, tankCol, newRow, newCol)) {
                            return {from: {row: ownStartRow, col: tankCol}, to: {row: newRow, col: newCol}};
                        }
                    }
                }
            } else {
                const opponentSide = getOpponentAssemblySide(opponent, opponentStartRow);
                const ownAssemblySide = opponentSide === 'left' ? 'right' : 'left';
                if (ownChipsOnStart.length > 1) {
                    ownChipsOnStart.sort((a, b) => ownAssemblySide === 'left' ? a.col - b.col : b.col - a.col);
                    for (let i = 1; i < ownChipsOnStart.length; i++) {
                        const targetCol = ownChipsOnStart[0].col;
                        const currentCol = ownChipsOnStart[i].col;
                        if (ownAssemblySide === 'left' && currentCol > targetCol) {
                            if (isValidMove(ownStartRow, currentCol, ownStartRow, currentCol - 1)) {
                                const movingWeight = board[ownStartRow][currentCol].weight;
                                const targetWeight = board[ownStartRow][targetCol].weight;
                                if (movingWeight !== targetWeight) {
                                    return {
                                        from: {row: ownStartRow, col: currentCol},
                                        to: {row: ownStartRow, col: targetCol}
                                    };
                                }
                            }
                        } else if (ownAssemblySide === 'right' && currentCol < targetCol) {
                            if (isValidMove(ownStartRow, currentCol, ownStartRow, currentCol + 1)) {
                                const movingWeight = board[ownStartRow][currentCol].weight;
                                const targetWeight = board[ownStartRow][targetCol].weight;
                                if (movingWeight !== targetWeight) {
                                    return {
                                        from: {row: ownStartRow, col: currentCol},
                                        to: {row: ownStartRow, col: targetCol}
                                    };
                                }
                            }
                        }
                    }
                }
                if (ownChipsOnStart.length === 1) {
                    const tankCol = ownChipsOnStart[0].col;
                    const safeMove = findSafePathToGoal(player, ownStartRow, tankCol);
                    if (safeMove) return safeMove;
                }
                return getTankMove(player);
            }
        }
        return getTankMove(player);
    }

    // Стратегия "Призрак" для уровня 6 - обновлена под новые правила
    function getGhostMove(player) {
        const opponent = player === 1 ? 2 : 1;
        const startRow = player === 1 ? BOARD_SIZE - 1 : 0;
        const targetRow = player === 1 ? 0 : BOARD_SIZE - 1;

        let ownChips = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (board[row][col] && board[row][col].player === player) {
                    ownChips.push({row, col, weight: board[row][col].weight});
                }
            }
        }

        let startRowChips = ownChips.filter(chip => chip.row === startRow);
        if (startRowChips.length > 2) {
            startRowChips.sort((a, b) => a.col - b.col);
            for (let i = 0; i < startRowChips.length - 1; i += 2) {
                const chip1 = startRowChips[i];
                const chip2 = startRowChips[i + 1];
                if (Math.abs(chip1.col - chip2.col) === 1) {
                    // Проверяем, что объединение не приведет к уничтожению
                    if (chip1.weight !== chip2.weight) {
                        if (isValidMove(chip2.row, chip2.col, chip1.row, chip1.col)) {
                            return {from: {row: chip2.row, col: chip2.col}, to: {row: chip1.row, col: chip1.col}};
                        }
                    }
                }
            }
        }

        let bestMove = null;
        let bestScore = -Infinity;
        for (const chip of ownChips) {
            const directions = player === 1 ? [[-1, -1], [-1, 0], [-1, 1]] : [[1, -1], [1, 0], [1, 1]];
            for (const [dRow, dCol] of directions) {
                const newRow = chip.row + dRow;
                const newCol = chip.col + dCol;
                if (!isValidMove(chip.row, chip.col, newRow, newCol)) continue;
                let score = 0;
                const distanceToGoal = player === 1 ? newRow : (BOARD_SIZE - 1 - newRow);
                score += (BOARD_SIZE - distanceToGoal) * 10;
                const cellElement = document.querySelector(`.cell[data-row="${newRow}"][data-col="${newCol}"]`);
                if (cellElement && cellElement.classList.contains('plus')) {
                    score += 8;
                }
                if (cellElement && cellElement.classList.contains('minus')) {
                    score -= 3;
                }
                if (board[newRow][newCol] && board[newRow][newCol].player === opponent) {
                    score -= 100;
                }
                const threatDirections = getMoveDirections();
                for (const [tdRow, tdCol] of threatDirections) {
                    const threatRow = newRow + tdRow;
                    const threatCol = newCol + tdCol;
                    const colsInThreatRow = BOARD_TYPE === 'hex' ? (threatRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
                    if (threatRow >= 0 && threatRow < BOARD_SIZE && threatCol >= 0 && threatCol < colsInThreatRow) {
                        if (board[threatRow][threatCol] && board[threatRow][threatCol].player === opponent) {
                            const dist = Math.abs(threatRow - newRow) + Math.abs(threatCol - newCol);
                            if (dist <= 2) {
                                score -= (3 - dist) * 15;
                            }
                        }
                    }
                }
                if (chip.weight < 8) {
                    score += 5;
                } else if (chip.weight > 12) {
                    score -= 10;
                }
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = {from: {row: chip.row, col: chip.col}, to: {row: newRow, col: newCol}};
                }
            }
        }
        if (bestMove) return bestMove;
        return getBestMoveAdvanced(player, 'ai3');
    }

    // Стратегия "Маг" для уровня 7 - обновлена под новые правила
    function getMageMove(player) {
        const opponent = player === 1 ? 2 : 1;
        const startRow = player === 1 ? BOARD_SIZE - 1 : 0;
        const targetRow = player === 1 ? 0 : BOARD_SIZE - 1;

        let ghostThreats = [];
        let ownChips = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (board[row][col]) {
                    if (board[row][col].player === opponent) {
                        if (board[row][col].weight <= 8 && row !== (opponent === 1 ? BOARD_SIZE - 1 : 0)) {
                            ghostThreats.push({row, col, weight: board[row][col].weight});
                        }
                    } else if (board[row][col].player === player) {
                        ownChips.push({row, col, weight: board[row][col].weight});
                    }
                }
            }
        }

        if (ghostThreats.length > 0) {
            ghostThreats.sort((a, b) => {
                const distA = player === 1 ? a.row : (BOARD_SIZE - 1 - a.row);
                const distB = player === 1 ? b.row : (BOARD_SIZE - 1 - b.row);
                return distA - distB;
            });
            const targetGhost = ghostThreats[0];
            for (const chip of ownChips) {
                const rowDiff = Math.abs(targetGhost.row - chip.row);
                const colDiff = Math.abs(targetGhost.col - chip.col);
                if (rowDiff <= 2 && colDiff <= 2) {
                    const moves = getAllValidMovesForChip(chip.row, chip.col, player);
                    for (const move of moves) {
                        if (move.to.row === targetGhost.row && move.to.col === targetGhost.col) {
                            return move;
                        }
                        if (isBlockingGhostPath(move.to, targetGhost, player)) {
                            return move;
                        }
                    }
                }
            }
        }

        let startRowChips = ownChips.filter(chip => chip.row === startRow);
        if (startRowChips.length > 2) {
            startRowChips.sort((a, b) => a.col - b.col);
            for (let i = 0; i < startRowChips.length - 1; i += 2) {
                const chip1 = startRowChips[i];
                const chip2 = startRowChips[i + 1];
                if (Math.abs(chip1.col - chip2.col) === 1) {
                    if (chip1.weight !== chip2.weight) {
                        if (isValidMove(chip2.row, chip2.col, chip1.row, chip1.col)) {
                            return {from: {row: chip2.row, col: chip2.col}, to: {row: chip1.row, col: chip1.col}};
                        }
                    }
                }
            }
        }

        let bestMove = null;
        let bestScore = -Infinity;
        for (const chip of ownChips) {
            const directions = player === 1 ? [[-1, -1], [-1, 0], [-1, 1]] : [[1, -1], [1, 0], [1, 1]];
            for (const [dRow, dCol] of directions) {
                const newRow = chip.row + dRow;
                const newCol = chip.col + dCol;
                if (!isValidMove(chip.row, chip.col, newRow, newCol)) continue;
                let score = 0;
                const distanceToGoal = player === 1 ? newRow : (BOARD_SIZE - 1 - newRow);
                score += (BOARD_SIZE - distanceToGoal) * 15;
                const cellElement = document.querySelector(`.cell[data-row="${newRow}"][data-col="${newCol}"]`);
                if (cellElement && cellElement.classList.contains('plus')) {
                    score += 10;
                }
                if (cellElement && cellElement.classList.contains('minus')) {
                    score -= 5;
                }
                if (board[newRow][newCol] && board[newRow][newCol].player === opponent) {
                    if (board[newRow][newCol].weight > 8) {
                        score -= 80;
                    } else {
                        score += 50;
                    }
                }
                const newWeight = chip.weight + (board[newRow][newCol] && board[newRow][newCol].player === player ? board[newRow][newCol].weight : 0);
                if (newWeight >= 6 && newWeight <= 12) {
                    score += 20;
                } else if (newWeight > 12) {
                    score -= 10;
                }
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = {from: {row: chip.row, col: chip.col}, to: {row: newRow, col: newCol}};
                }
            }
        }
        if (bestMove) return bestMove;
        return getBestMoveAdvanced(player, 'ai3');
    }

    // Получение всех ходов для конкретной фишки
    function getAllValidMovesForChip(row, col, player) {
        const moves = [];
        const directions = getMoveDirections();
        for (const [dRow, dCol] of directions) {
            const newRow = row + dRow;
            const newCol = col + dCol;
            if (isValidMove(row, col, newRow, newCol)) {
                moves.push({from: {row, col}, to: {row: newRow, col: newCol}});
            }
        }
        return moves;
    }

    // Проверка, блокирует ли позиция путь Призрака
    function isBlockingGhostPath(pos, ghost, player) {
        const directions = player === 1 ? [[-1, -1], [-1, 0], [-1, 1]] : [[1, -1], [1, 0], [1, 1]];
        for (const [dRow, dCol] of directions) {
            const nextRow = ghost.row + dRow;
            const nextCol = ghost.col + dCol;
            if (nextRow === pos.row && nextCol === pos.col) {
                return true;
            }
        }
        return false;
    }

    // Стратегия "Метаморф" для уровня 8 - обновлена под новые правила
    function getMetamorphMove(player) {
        const opponent = player === 1 ? 2 : 1;
        const opponentStrategy = detectOpponentStrategy(opponent);
        switch (opponentStrategy) {
            case 'tank':
                return getAntiTankMove(player);
            case 'anti_tank':
                return getTankMove(player);
            case 'ghost':
                return getMageMove(player);
            case 'mage':
                return getGhostMove(player);
            case 'metamorph':
            case 'knowledge':
            case 'absolyaris':
            case 'secret':
                return getHybridMove(player);
            default:
                return getBalancedMove(player);
        }
    }

    // Обнаружение стратегии противника
    function detectOpponentStrategy(opponent) {
        const startRow = opponent === 1 ? BOARD_SIZE - 1 : 0;
        let opponentChips = [];
        let totalWeight = 0;
        let maxWeight = 0;
        let mobileChips = 0;
        for (let row = 0; row < BOARD_SIZE; row++) {
            const colsInRow = BOARD_TYPE === 'hex' ? (row % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            for (let col = 0; col < colsInRow; col++) {
                if (board[row][col] && board[row][col].player === opponent) {
                    const chip = board[row][col];
                    opponentChips.push({row, col, weight: chip.weight});
                    totalWeight += chip.weight;
                    maxWeight = Math.max(maxWeight, chip.weight);
                    if (chip.weight <= 8 && row !== startRow) {
                        mobileChips++;
                    }
                }
            }
        }
        if (opponentChips.length === 1 && maxWeight > 15) {
            return 'tank';
        } else if (opponentChips.length === 1 && maxWeight > 10) {
            return 'anti_tank';
        } else if (mobileChips >= 2 && maxWeight <= 8) {
            return 'ghost';
        } else if (mobileChips === 1 && maxWeight > 8 && totalWeight > 20) {
            return 'mage';
        } else if (opponentChips.length >= 3 && totalWeight > 25) {
            return 'metamorph';
        } else if (opponentChips.length === 2 && totalWeight > 18) {
            return 'knowledge';
        } else if (opponentChips.length === 1 && totalWeight > 30) {
            return 'absolyaris';
        } else if (opponentChips.length > 4) {
            return 'secret';
        }
        return 'unknown';
    }

    // Гибридный ход для Метаморфа - обновлен под новые правила
    function getHybridMove(player) {
        const moves = getAllValidMoves(player);
        if (moves.length === 0) return null;
        let bestMove = moves[0];
        let bestScore = -Infinity;
        for (const move of moves) {
            let score = 0;
            score += (player === 1 ? move.from.row - move.to.row : move.to.row - move.from.row) * 8;
            if (board[move.to.row][move.to.col] && board[move.to.row][move.to.col].player === player) {
                const moving = board[move.from.row][move.from.col].weight;
                const target = board[move.to.row][move.to.col].weight;
                if (moving < target) {
                    score += (moving + target) * 2;
                } else if (moving > target) {
                    score += (moving - target) * 1.5;
                } else {
                    score -= 50;
                }
            }
            if (board[move.to.row][move.to.col] && board[move.to.row][move.to.col].player !== player) {
                if (board[move.to.row][move.to.col].weight > 10) {
                    score -= 50;
                } else {
                    score += 10;
                }
            }
            const cellElement = document.querySelector(`.cell[data-row="${move.to.row}"][data-col="${move.to.col}"]`);
            if (cellElement && cellElement.classList.contains('plus')) {
                score += 7;
            }
            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }
        }
        return bestMove;
    }

    // Сбалансированный ход
    function getBalancedMove(player) {
        return getBestMoveAdvanced(player, 'ai3');
    }

    // Стратегия "Знание" для уровня 9 - обновлена под новые правила
    function getKnowledgeMove(player) {
        const opponent = player === 1 ? 2 : 1;
        let bestMove = null;
        let bestScore = -Infinity;
        const moves = getAllValidMoves(player);
        for (const move of moves) {
            let score = 0;
            const distanceGain = player === 1 ? (move.from.row - move.to.row) : (move.to.row - move.from.row);
            score += distanceGain * 12;
            let weightChange = 0;
            if (board[move.to.row][move.to.col] && board[move.to.row][move.to.col].player === player) {
                const moving = board[move.from.row][move.from.col].weight;
                const target = board[move.to.row][move.to.col].weight;
                if (moving < target) {
                    weightChange = moving + target;
                } else if (moving > target) {
                    weightChange = moving - target;
                } else {
                    weightChange = -100;
                }
            } else {
                const cellElement = document.querySelector(`.cell[data-row="${move.to.row}"][data-col="${move.to.col}"]`);
                if (cellElement && cellElement.classList.contains('plus')) {
                    weightChange = 1;
                } else if (cellElement && cellElement.classList.contains('minus')) {
                    weightChange = -1;
                }
            }
            score += weightChange * 8;
            const opponentThreat = assessOpponentThreat(move.to.row, move.to.col, opponent);
            score -= opponentThreat * 10;
            if (move.from.row === (player === 1 ? BOARD_SIZE - 1 : 0)) {
                score += 5;
            }
            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }
        }
        return bestMove || getBestMoveAdvanced(player, 'ai3');
    }

    // Оценка угрозы от противника
    function assessOpponentThreat(row, col, opponent) {
        let threat = 0;
        const directions = getMoveDirections();
        for (const [dRow, dCol] of directions) {
            const checkRow = row + dRow;
            const checkCol = col + dCol;
            const colsInRow = BOARD_TYPE === 'hex' ? (checkRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            if (checkRow >= 0 && checkRow < BOARD_SIZE && checkCol >= 0 && checkCol < colsInRow) {
                if (board[checkRow][checkCol] && board[checkRow][checkCol].player === opponent) {
                    threat += board[checkRow][checkCol].weight;
                }
            }
        }
        return threat;
    }

    // Стратегия "Абсолярис" для уровня 10 - обновлена под новые правила
    function getAbsolyarisMove(player) {
        const moves = getAllValidMoves(player);
        if (moves.length === 0) return null;
        moves.sort((a, b) => {
            const impactA = calculateMoveImpact(a, player);
            const impactB = calculateMoveImpact(b, player);
            return impactB - impactA;
        });
        return moves[0];
    }

    // Расчет влияния хода
    function calculateMoveImpact(move, player) {
        let impact = 0;
        impact += calculateSpaceControl(move.to.row, move.to.col, player);
        impact += calculatePositionalFlexibility(move.to.row, move.to.col, player);
        impact += calculateInitiativeGain(move, player);
        return impact;
    }

    // Контроль пространства
    function calculateSpaceControl(row, col, player) {
        let control = 0;
        const directions = getMoveDirections();
        for (const [dRow, dCol] of directions) {
            const checkRow = row + dRow;
            const checkCol = col + dCol;
            const colsInRow = BOARD_TYPE === 'hex' ? (checkRow % 2 === 0 ? BOARD_SIZE : BOARD_SIZE - 1) : BOARD_SIZE;
            if (checkRow >= 0 && checkRow < BOARD_SIZE && checkCol >= 0 && checkCol < colsInRow) {
                if (!board[checkRow][checkCol]) {
                    control += 1;
                }
            }
        }
        return control;
    }

    // Позиционная гибкость
    function calculatePositionalFlexibility(row, col, player) {
        let flexibility;
        const futureMoves = getAllValidMovesFromPosition(row, col, player);
        flexibility = futureMoves.length;
        return flexibility;
    }

    // Получение возможных ходов из позиции
    function getAllValidMovesFromPosition(row, col, player) {
        const moves = [];
        const directions = getMoveDirections();
        for (const [dRow, dCol] of directions) {
            const newRow = row + dRow;
            const newCol = col + dCol;
            const fakeBoard = copyBoard();
            fakeBoard[row][col] = {player: player, weight: 1};
            if (isValidMove(row, col, newRow, newCol)) {
                moves.push({from: {row, col}, to: {row: newRow, col: newCol}});
            }
        }
        return moves;
    }

    // Прирост инициативы
    function calculateInitiativeGain(move, player) {
        let initiative = 0;
        if (player === 1 && move.to.row < move.from.row) {
            initiative += 5;
        } else if (player === 2 && move.to.row > move.from.row) {
            initiative += 5;
        }
        return initiative;
    }

    // Стратегия "Секрет" для уровня 11 - обновлена под новые правила
    function getSecretMove(player) {
        const strategies = [
            getTankMove,
            getAntiTankMove,
            getGhostMove,
            getMageMove,
            getMetamorphMove,
            getKnowledgeMove,
            getAbsolyarisMove
        ];
        const randomStrategy = strategies[Math.floor(Math.random() * strategies.length)];
        const move = randomStrategy(player);
        if (!move) {
            return getBestMoveAdvanced(player, 'ai3');
        }
        if (Math.random() < 0.1) {
            const allMoves = getAllValidMoves(player);
            if (allMoves.length > 1) {
                const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                if (randomMove !== move) {
                    return randomMove;
                }
            }
        }
        return move;
    }

    // Выбор лучшего хода ИИ с улучшенной логикой - обновлен под новые правила
    function getBestMoveAdvanced(player, level) {
        const moves = getAllValidMoves(player);
        if (moves.length === 0) return null;
        if (moves.length === 1) return moves[0];
        const depth = level === 'ai3' ? 5 : (level === 'ai2' ? 4 : 3);
        let bestMove = moves[0];
        let bestValue = -Infinity;
        moves.sort((a, b) => {
            let aScore = 0;
            let bScore = 0;
            aScore += (player === 1 ? a.from.row - a.to.row : a.to.row - a.from.row) * 10;
            bScore += (player === 1 ? b.from.row - b.to.row : b.to.row - b.from.row) * 10;
            if (board[a.to.row][a.to.col] && board[a.to.row][a.to.col].player === player) {
                const moving = board[a.from.row][a.from.col].weight;
                const target = board[a.to.row][a.to.col].weight;
                if (moving < target) {
                    aScore += (moving + target) * 5;
                } else if (moving > target) {
                    aScore += (moving - target) * 3;
                } else {
                    aScore -= 100;
                }
            }
            if (board[b.to.row][b.to.col] && board[b.to.row][b.to.col].player === player) {
                const moving = board[b.from.row][b.from.col].weight;
                const target = board[b.to.row][b.to.col].weight;
                if (moving < target) {
                    bScore += (moving + target) * 5;
                } else if (moving > target) {
                    bScore += (moving - target) * 3;
                } else {
                    bScore -= 100;
                }
            }
            return bScore - aScore;
        });
        for (const move of moves) {
            const boardCopy = copyBoard();
            applyMoveToBoard(boardCopy, move, player);
            const moveValue = minimaxAdvanced(boardCopy, depth, -Infinity, Infinity, false, player === 1 ? 2 : 1, player);
            if (moveValue > bestValue) {
                bestValue = moveValue;
                bestMove = move;
            }
        }
        return bestMove;
    }

    // Выполнение хода ИИ
    function makeAIMove() {
        if (!gameActive) return;
        const playerType = currentPlayer === 1 ? player1Type : player2Type;
        if (playerType === 'human') return;
        document.getElementById('thinking').style.color = 'red';
        setTimeout(() => {
            let bestMove;
            switch (playerType) {
                case 'ai11':
                    bestMove = getSecretMove(currentPlayer);
                    break;
                case 'ai10':
                    bestMove = getAbsolyarisMove(currentPlayer);
                    break;
                case 'ai9':
                    bestMove = getKnowledgeMove(currentPlayer);
                    break;
                case 'ai8':
                    bestMove = getMetamorphMove(currentPlayer);
                    break;
                case 'ai7':
                    bestMove = getMageMove(currentPlayer);
                    break;
                case 'ai6':
                    bestMove = getGhostMove(currentPlayer);
                    break;
                case 'ai5':
                    bestMove = getAntiTankMove(currentPlayer);
                    break;
                case 'ai4':
                    bestMove = getTankMove(currentPlayer);
                    break;
                default:
                    bestMove = getBestMoveAdvanced(currentPlayer, playerType);
            }
            document.getElementById('thinking').style.color = 'white';
            if (bestMove) {
                moveChip(bestMove.from.row, bestMove.from.col, bestMove.to.row, bestMove.to.col);
                if (checkWhiteReached()) {
                    whiteReached = true;
                    if (hasBlackChips() && !lastBlackMoveDone) {
                        currentPlayer = 2;
                        lastBlackMoveDone = true;
                        document.getElementById('game-info').textContent = `Последний ход игрока 2`;
                        if (player2Type !== 'human') {
                            makeAIMove();
                        }
                    } else {
                        endGame();
                    }
                } else if (checkBlackReached()) {
                    blackReached = true;
                    endGame();
                } else {
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    document.getElementById('game-info').textContent = `Ход игрока ${currentPlayer}`;
                    const nextPlayerType = currentPlayer === 1 ? player1Type : player2Type;
                    if (nextPlayerType !== 'human') {
                        makeAIMove();
                    }
                }
            } else {
                if (whiteReached) {
                    if (hasBlackChips() && !lastBlackMoveDone) {
                        currentPlayer = 2;
                        lastBlackMoveDone = true;
                        document.getElementById('game-info').textContent = `Последний ход игрока 2`;
                        if (player2Type !== 'human') {
                            makeAIMove();
                        } else {
                            endGame();
                        }
                    } else {
                        endGame();
                    }
                } else if (checkBlackReached()) {
                    blackReached = true;
                    endGame();
                } else {
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    document.getElementById('game-info').textContent = `Ход игрока ${currentPlayer}`;
                    const nextPlayerType = currentPlayer === 1 ? player1Type : player2Type;
                    if (nextPlayerType !== 'human') {
                        makeAIMove();
                    }
                }
            }
        }, 100);
    }

    // Обработка клика по клетке
    function handleCellClick(row, col) {
        if (!gameActive) return;
        const currentPlayerType = currentPlayer === 1 ? player1Type : player2Type;
        if (currentPlayerType !== 'human') return;
        const cell = board[row][col];
        if (cell && cell.player === currentPlayer && selectedChip === null) {
            selectedChip = {row, col};
            highlightValidMoves(row, col);
            return;
        }
        if (selectedChip !== null) {
            const fromRow = selectedChip.row;
            const fromCol = selectedChip.col;
            const toRow = row;
            const toCol = col;
            if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                moveChip(fromRow, fromCol, toRow, toCol);
                selectedChip = null;
                clearHighlights();
                if (checkWhiteReached()) {
                    whiteReached = true;
                    if (hasBlackChips() && !lastBlackMoveDone) {
                        currentPlayer = 2;
                        lastBlackMoveDone = true;
                        document.getElementById('game-info').textContent = `Последний ход игрока 2`;
                        if (player2Type !== 'human') {
                            makeAIMove();
                        }
                    } else {
                        endGame();
                    }
                } else if (checkBlackReached()) {
                    blackReached = true;
                    endGame();
                } else {
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    document.getElementById('game-info').textContent = `Ход игрока ${currentPlayer}`;
                    const nextPlayerType = currentPlayer === 1 ? player1Type : player2Type;
                    if (nextPlayerType !== 'human') {
                        makeAIMove();
                    }
                }
            } else {
                if (cell && cell.player === currentPlayer) {
                    clearHighlights();
                    selectedChip = {row, col};
                    highlightValidMoves(row, col);
                } else {
                    clearHighlights();
                    selectedChip = null;
                }
            }
        }
    }

    // Подсветка допустимых ходов
    function highlightValidMoves(row, col) {
        const directions = getMoveDirections();
        for (const [dRow, dCol] of directions) {
            const newRow = row + dRow;
            const newCol = col + dCol;
            if (isValidMove(row, col, newRow, newCol)) {
                const cell = document.querySelector(`.cell[data-row="${newRow}"][data-col="${newCol}"]`);
                if (cell) cell.classList.add('highlight');
            }
        }
    }

    // Очистка подсветки
    function clearHighlights() {
        document.querySelectorAll('.cell').forEach(cell => {
            cell.classList.remove('highlight');
        });
    }

    // Проверка валидности хода
    function isValidMove(fromRow, fromCol, toRow, toCol) {
        if (fromRow === toRow && fromCol === toCol) return false;
        if (BOARD_TYPE === 'hex') {
            return isValidHexMove(fromRow, fromCol, toRow, toCol, currentPlayer);
        }
        if (toRow < 0 || toRow >= BOARD_SIZE || toCol < 0 || toCol >= BOARD_SIZE) return false;
        const dRow = toRow - fromRow;
        const dCol = toCol - fromCol;
        if (Math.abs(dRow) > 1 || Math.abs(dCol) > 1) return false;
        if (board[toRow][toCol] && board[toRow][toCol].player === currentPlayer) {
            return true;
        }
        if (Math.abs(dRow) <= 1 && Math.abs(dCol) <= 1) {
            if (currentPlayer === 1 && dRow > 0) return false;
            return !(currentPlayer === 2 && dRow < 0);

        }
        return false;
    }

    // Перемещение фишки с учетом новых правил
    function moveChip(fromRow, fromCol, toRow, toCol) {
        const chip = board[fromRow][fromCol];
        board[fromRow][fromCol] = null;

        if (board[toRow][toCol] && board[toRow][toCol].player === currentPlayer) {
            const targetChip = board[toRow][toCol];
            if (chip.weight < targetChip.weight) {
                board[toRow][toCol].weight = chip.weight + targetChip.weight;
            } else if (chip.weight > targetChip.weight) {
                board[toRow][toCol].weight = chip.weight - targetChip.weight;
            } else {
                board[toRow][toCol] = null;
            }
            renderBoard();
            return;
        }

        const cellElement = document.querySelector(`.cell[data-row="${toRow}"][data-col="${toCol}"]`);
        let hasPlus = false;
        let hasMinus = false;
        if (cellElement) {
            hasPlus = cellElement.classList.contains('plus');
            hasMinus = cellElement.classList.contains('minus');
        }

        if (board[toRow][toCol]) {
            const enemyChip = board[toRow][toCol];
            if (COLLISION_MODE === 'field-effect') {
                if (hasPlus) {
                    chip.weight += enemyChip.weight;
                    board[toRow][toCol] = chip;
                } else if (hasMinus) {
                    if (chip.weight > enemyChip.weight) {
                        chip.weight -= enemyChip.weight;
                        board[toRow][toCol] = chip;
                    } else if (enemyChip.weight > chip.weight) {
                        enemyChip.weight -= chip.weight;
                        board[toRow][toCol] = enemyChip;
                    } else {
                        board[toRow][toCol] = null;
                    }
                } else {
                    if (chip.weight > enemyChip.weight) {
                        chip.weight -= enemyChip.weight;
                        board[toRow][toCol] = chip;
                    } else if (enemyChip.weight > chip.weight) {
                        enemyChip.weight -= chip.weight;
                        board[toRow][toCol] = enemyChip;
                    } else {
                        board[toRow][toCol] = null;
                    }
                }
            } else {
                if (chip.weight > enemyChip.weight) {
                    chip.weight -= enemyChip.weight;
                    board[toRow][toCol] = chip;
                } else if (enemyChip.weight > chip.weight) {
                    enemyChip.weight -= chip.weight;
                    board[toRow][toCol] = enemyChip;
                } else {
                    board[toRow][toCol] = null;
                }
            }
        } else {
            if (hasPlus) {
                chip.weight += 1;
            } else if (hasMinus) {
                chip.weight -= 1;
                if (chip.weight <= 0) {
                    renderBoard();
                    return;
                }
            }
            board[toRow][toCol] = chip;
        }
        renderBoard();
    }

    // Начало новой игры
    function startNewGame() {
        currentPlayer = 1;
        whiteReached = false;
        blackReached = false;
        lastBlackMoveDone = false;
        gameActive = true;
        document.getElementById('game-info').textContent = 'Ход игрока 1';
        document.getElementById('thinking').style.color = 'white';
        initBoard();
        const nextPlayerType = currentPlayer === 1 ? player1Type : player2Type;
        if (nextPlayerType !== 'human') {
            makeAIMove();
        }
    }

    // Начать сначала
    function restartSameGame() {
        restoreInitialBoardState();
        currentPlayer = 1;
        whiteReached = false;
        blackReached = false;
        lastBlackMoveDone = false;
        gameActive = true;
        document.getElementById('game-info').textContent = 'Ход игрока 1';
        document.getElementById('thinking').style.color = 'white';
        const nextPlayerType = currentPlayer === 1 ? player1Type : player2Type;
        if (nextPlayerType !== 'human') {
            makeAIMove();
        }
    }

    // Валидация размера шестиугольной доски
    function validateBoardSize() {
        const sizeInput = document.getElementById('board-size');
        const boardType = document.getElementById('board-type').value;
        if (boardType === 'hex') {
            let size = parseInt(sizeInput.value.toString());
            if (size < 3) size = 3;
            if (size > 11) size = 11;
            if (size % 2 === 0) {
                size = size - 1;
                if (size < 3) size = 3;
            }
            sizeInput.value = size;
        }
    }

    // Обработчики кнопок
    document.getElementById('restart').addEventListener('click', restartSameGame);
    document.getElementById('rules-btn').addEventListener('click', () => {
        document.getElementById('rules-modal').style.display = 'block';
    });
    document.getElementById('close-rules').addEventListener('click', () => {
        document.getElementById('rules-modal').style.display = 'none';
    });
    document.getElementById('new-game-btn').addEventListener('click', () => {
        document.getElementById('size-selector').style.display = 'block';
    });
    document.getElementById('cancel-size').addEventListener('click', () => {
        document.getElementById('size-selector').style.display = 'none';
    });
    document.getElementById('confirm-size').addEventListener('click', () => {
        validateBoardSize();
        const newSize = parseInt(document.getElementById('board-size').value);
        const newType = document.getElementById('board-type').value;
        const collisionMode = document.getElementById('collision-mode').value;
        if (newType === 'hex') {
            if (newSize < 3 || newSize > 11 || newSize % 2 === 0) {
                alert('Размер шестиугольной доски должен быть нечетным числом от 3 до 11!');
                return;
            }
        } else {
            if (newSize < 3 || newSize > 11) {
                alert('Размер квадратной доски должен быть от 3 до 11!');
                return;
            }
        }
        BOARD_SIZE = newSize;
        BOARD_TYPE = newType;
        COLLISION_MODE = collisionMode;
        document.getElementById('size-selector').style.display = 'none';
        document.getElementById('ai-settings').style.display = 'block';
    });
    document.getElementById('cancel-ai').addEventListener('click', () => {
        document.getElementById('ai-settings').style.display = 'none';
    });
    document.getElementById('confirm-ai').addEventListener('click', () => {
        player1Type = document.getElementById('player1-type').value;
        player2Type = document.getElementById('player2-type').value;
        document.getElementById('ai-settings').style.display = 'none';
        createBoard();
        startNewGame();
    });

    // Инициализация игры
    createBoard();
    initBoard();
</script>
</body>
</html>